var run = require('./src/run')

var _ = require('lodash')
var epub = require('epub-gen')
var fs = require('fs')
var async = require('async')
var slug = require('slug')
var moment = require('moment')

const tocObjToHtml = require('./src/tocObjToHtml')

function getEpubOptions (tocObj) {
  return {
    title: tocObj.title,
    cover: tocObj.cover,
    author: tocObj.author,
    css: 'code,pre{font-size: 0.9em;background:#fafafa;padding:0.5em;display:block;margin:0.5rem 0}',
    content: _.chain(tocObj.content).filter(el => el.result).map(tocEl => {
      return {
        title: tocEl.title,
        data: tocEl.result ? tocEl.result.content : ''
      }
    }).value()
  }
}

function execCommand (command, cb) {
  var sys = require('sys')
  var exec = require('child_process').exec
  function puts (error, stdout, stderr) {
    if (error) throw(error)
    sys.puts(stdout)
    cb()
  }
  exec(command, puts)
}

// generations trategies
function generateEpubFromHtml (tocArray) {
  var epubOptions = getEpubOptions(tocArray)
  new epub(epubOptions, 'docs/download/' + strategyToRun + '.epub')
}

function generateHtmlFromHtml (tocArray) {
  fs.writeFile('docs/download/' + strategyToRun + '.html', tocObjToHtml(tocArray), (err, res) => {
    // console.log({err, res})
  })
}

function generateEpubMetadata (docObj) {
  return new Promise(function (resolve, reject) {
    var epubMeta = `

---
title:
- type: main
  text: ${docObj.title}
creator:
- role: author
  text: ${docObj.author}
rights: ${docObj.licenceUrl}
include-before: Documentation for <b>${docObj.title}</b> ([${docObj.docsUrl}](${docObj.docsUrl})) generated by <b>docs2epub</b> ([http://javier.xyz/docs2epub/](http://javier.xyz/docs2epub/)) on ${moment().format('YYYY/MM/DD')}.
date: ${moment().format('YYYY/MM/DD')}
description: Documentation for <b>${docObj.title}</b> ([${docObj.docsUrl}](${docObj.docsUrl})) generated by <b>docs2epub</b> ([http://javier.xyz/docs2epub/](http://javier.xyz/docs2epub/)) on ${moment().format('YYYY/MM/DD')}.
...

    `
    fs.writeFile(`_tmp/epub/${slug(docObj.title)}/meta.txt`, epubMeta, (err, res) => {
      if (err) {
        reject(err)
        return
      }
      resolve(res)
    })
  })
}

function generateEpubFromMarkdown (docObj) {
  return new Promise(function (resolve, reject) {
    execCommand(`rm -rf _tmp/epub/${slug(docObj.title)} && mkdir -p _tmp/epub/${slug(docObj.title)}`, () => {
      async.map(docObj.content, (tocEl, cb) => {
        if (tocEl.result) {
          fs.writeFile(`_tmp/epub/${slug(docObj.title)}/${tocEl.index}.md`, tocEl.result.content, cb)
        }
      }, (err, res) => {
        var pandocCommand = `pandoc -s -o docs/download/${docObj.title.toLowerCase()}.epub _tmp/epub/${slug(docObj.title)}/meta.txt `
        pandocCommand += _.map(docObj.content, tocEl => `_tmp/epub/${slug(docObj.title)}/${tocEl.index}.md `).join('')

        if (docObj.cover) {
          pandocCommand += `--epub-cover-image=${docObj.cover} `
        }

        if (docObj.epubStylesheet) {
          pandocCommand += `--epub-stylesheet=${docObj.epubStylesheet} `
        }

        if (docObj.epubTOCDepth) {
          pandocCommand += `--table-of-contents --toc-depth=${docObj.epubTOCDepth}`
        }

        generateEpubMetadata(docObj).then(() => {
          execCommand(pandocCommand, () => {
            console.log('Done.')
          })
        }, reject)
      })
    })
  })
}

var strategyToRun = 'react'

run(strategyToRun).then(tocArray => {
  if (tocArray.type === 'MARKDOWN') {
    generateEpubFromMarkdown(tocArray).catch(err => console.log(err))
  } else {
    generateEpubFromHtml(tocArray)
    generateHtmlFromHtml(tocArray)
  }
}).catch(err => {
  console.log(err.stack)
})
